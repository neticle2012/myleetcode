# 16.05. 阶乘尾数

[力扣题目链接](https://leetcode-cn.com/problems/factorial-zeros-lcci/)


# 初见思路(看过隐藏提示)

## 基本思路

`n!`中的每个`0`表示`n`能被`10`整除一次，表示包含有一个因数`10`，即一个因数`5`和一个因数`2`，因此`n!=n*(n-1)*(n-2)*...*1`中因数`10`的个数即为尾数中`0`的个数，所以去求`1~n`中因数`2`的个数和因数`5`的个数的最小值返回即可。而`1~n`中因数`5`的个数必定小于因数`2`的个数，所以最终变成求出`1~n`中因数`5`的个数返回。而注意到

- 数字`(5)*1`、`(5)*2`、`(5)*3`、`(5)*4`、`(5)*6`、`(5)*7`、`(5)*8`、`(5)*9`、`(5)*11`...中都含有一个因数`5`
- 数字`(5*5)*1`、`(5*5)*2`、`(5*5)*3`、`(5*5)*4`、`(5*5)*6`、`(5*5)*7`、`(5*5)*8`、`(5*5)*9`、`(5*5)*11`......中都含有两个因数`5`
- 数字`(5*5*5)*1`、`(5*5*5)*2`、`(5*5*5)*3`、`(5*5*5)*4`、`(5*5*5)*6`、`(5*5*5)*7`、`(5*5*5)*8`、`(5*5*5)*9`、`(5*5*5)*11`......中都含有三个因数`5`

所以对于`n!=n*(n-1)*(n-2)*...*1`而言，在`1~n`中，依次求出含有一个因数`5`的数字个数、含有两个因数`5`的数字个数、含有三个因数`5`的数字个数...，累加起来返回即可


## Java代码
```java
class Solution {
    //阶乘中因数5的个数，因为阶乘中因数5的个数必定小于因数2的个数，所以阶乘中因数5的个数即为因数10的个数
    private int cntFive;
    
    public int trailingZeroes(int n) {
        long pivotFive = 5;
        int cntPivotFive = 1;
        while (n >= pivotFive){
            int maxCnt = (int) (n / pivotFive);
            cntFive += (maxCnt / 5 * 4 + maxCnt % 5) * cntPivotFive;
            pivotFive *= 5;
            cntPivotFive++;
        }
        return cntFive;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(logN)$
- 空间复杂度：$O(1)$

# 民间解法

## 基本思路

通过观察`n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) ...`可以发现

- 每隔 `5` 个数就会出现 一个 `5`，因此我们只需要通过 `n / 5` 来计算存在多少个 `5`，那么就对应的存在多少个 `5`
- 每隔 `25` 个数会出现 一个 `25`， 而 `25` 中存在 两个`5`，<strong>上面在计算存在多少个`5`的过程中，对于数字`25`，只计算了 `25` 中的一个 `5`，因此我们需要 `n / 25` 来计算存在多少个 `25`，加上它遗漏的 `5`</strong>
- 每隔 `125` 个数会出现一个 `125`，而 `125` 存在 三个 `5`，<strong>我们上面计算存在多少个`5`和存在多少个`25`的过程中，只计算了 `125` 的两个 `5`，因此我们需要 `n / 125` 来计算存在多少个 `125`，加上它遗漏的 `5`</strong>

因此可以得到`cntFive = n / 5 + n / 25 + n / 125 + ...`

## Java代码
```java
class Solution {
    public int trailingZeroes(int n) {
        int cntFive = 0;//阶乘中因数5的个数，因为阶乘中因数5的个数必定小于因数2的个数，所以阶乘中因数5的个数即为因数10的个数  
        while (n >= 5){
            n /= 5;
            cntFive += n;
        }
        return cntFive;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(logN)$
- 空间复杂度：$O(1)$