# 121. 买卖股票的最佳时机

[力扣题目链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

# 官方解法1

## 基本思路(动态规划)

首先理解题意，<strong>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票的意思是只能买卖一次</strong>

1. 确定dp数组以及下标的含义

要用一个<strong>二维dp数组</strong>来保存递推的结果，<strong>`dp[i][0]` 表示第`i`天持有股票所得最多现金，`dp[i][1]` 表示第`i`天不持有股票所得最多现金</strong>

2. 确定递推公式

- 如果第`i`天持有股票即`dp[i][0]`， 那么可以由两个状态推出来
	- 第`i - 1`天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
	- 第`i`天买入股票，所得现金就是买入今天的股票后所得现金即：`-prices[i]`

那么`dp[i][0]`应该选所得现金最大的，所以`dp[i][0] = max(dp[i - 1][0], -prices[i])`

- 如果第`i`天不持有股票即`dp[i][1]`， 也可以由两个状态推出来
	- 第`i - 1`天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
	- 第`i`天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

同样`dp[i][1]`取最大的，`dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])`

3. dp数组如何初始化

由递推公式 `dp[i][0] = max(dp[i - 1][0], -prices[i])` 和 `dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0])`可以看出其基础都是要从`dp[0][0]`和`dp[0][1]`推导出来

那么`dp[0][0]`表示第`0`天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以`dp[0][0] -= prices[0]`

`dp[0][1]`表示第`0`天不持有股票，不持有股票那么现金就是`0`，所以`dp[0][1] = 0`

4. 确定遍历顺序

从递推公式可以看出`dp[i]`都是有`dp[i - 1]`推导出来的，那么一定是从前向后遍历

5. 举例推导dp数组

<img src="../Pictures/121. 买卖股票的最佳时机.png" width="80%"/>

`dp[5][1]`就是最终结果。为什么不是`dp[5][0]`呢？<strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong>

## 边界问题

如果`prices`为`null`或者长度为`0`，直接返回`-1`

## Java代码
```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0){
            return -1;
        }
        
        // dp[i][0]代表第i天持有股票的最大收益
        // dp[i][1]代表第i天不持有股票的最大收益
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < prices.length; i++){
            dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i][0] + prices[i]);
        }
        return dp[prices.length - 1][1];
    }
}
```

## Java代码(滚动数组优化)
```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0){
            return -1;
        }

        // dp[i][0]代表第i天持有股票的最大收益
        // dp[i][1]代表第i天不持有股票的最大收益
        int[] dp = new int[2];//dp[i - 1][]
        dp[0] = -prices[0];
        dp[1] = 0;

        for (int i = 1; i < prices.length; i++){
            int[] temp = new int[2];
            dp[0] = Math.max(dp[0], -prices[i]);
            dp[1] = Math.max(dp[1], dp[0] + prices[i]);
        }
        return dp[1];
    }
}
```

## 复杂度分析
- 时间复杂度：$O(n)$，其中$n$为`prices`数组的长度
- 空间复杂度：$O(1)$

# 官方解法2

## 基本思路(贪心)

因为<strong>股票就买卖一次</strong>，如果是在历史最低点买的股票就好了！那么只要<strong>用一个变量`low`记录历史最低价格</strong>，就可以假设自己的股票是在那天买的

那么在第i天卖出股票能够得到的利润就是`prices[i] - low`

因此，只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果是在历史最低点买进的，那么今天卖出能赚多少钱？当考虑完所有天数之时，就得到了最好的答案

## 边界问题

如果`prices`为`null`或者长度为`0`，直接返回`-1`

## Java代码
```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0){
            return -1;
        }

        int res = 0;
        int low = Integer.MAX_VALUE;//找到一个最小的购入点
        for (int i = 0; i < prices.length; i++){
            low = Math.min(low, prices[i]);
            res = Math.max(res, prices[i] - low);
        }
        return res;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(n)$，其中$n$为`prices`数组的长度
- 空间复杂度：$O(1)$