# 17.11. 单词距离

[力扣题目链接](https://leetcode-cn.com/problems/find-closest-lcci/)


# 初见思路

## 基本思路
首先遍历一遍`String`数组`words`，将每个单词作为`key`，其在`words`中出现的所有索引组成的`ArrayList`集合作为`value`，添加到`HashMap`集合中，然后从集合中找到`word1`和`word2`对应的索引集合，问题转化成了如何在两个**排好序**的（因为索引是从小到大在`words`中遍历添加到`ArrayList`集合中的）`ArrayList`集合中找到差值最小的两个元素。

可以遍历其中的一个`ArrayList`集合，取出每个元素，然后从另一个`ArrayList`集合中找到最接近该元素的区间，例如取出的元素为`2`，另一个`ArrayList`集合的元素为`[0,1,3,5,6]`，那么返回`1`和`3`。显然该逻辑可以使用修改过的二分查找来完成

## 边界问题
`words`数组为`null`或者`word1`为`null`或者`word2`为`null`时，直接返回`-1`。

如果`word1`或者`word2`的索引集合不存在，或者`word1`与`word2`是同一个单词，则直接返回`words`数组的长度

## Java代码
```java
class Solution {
    public int findClosest(String[] words, String word1, String word2) {
        if (words == null || word1 == null || word2 == null){
            return -1;
        }
        HashMap<String, ArrayList<Integer>> map = new HashMap<>();
        for (int i = 0; i < words.length; i++){
            if (!map.containsKey(words[i])){
                map.put(words[i], new ArrayList<>());
            }
            map.get(words[i]).add(i);
        }

        //我们从HashMap集合中拿出较短单词的索引集合进行遍历，对于每个索引，将其设为目标值
        //在较长单词的对应的索引集合中进行二分查找，找到最接近目标值的索引
        ArrayList<Integer> indexArr1 = map.get(word1);
        ArrayList<Integer> indexArr2 = map.get(word2);
        if (indexArr1 == null || indexArr2 == null || word1.equals(word2)){//两个单词必须有他们的索引集合，而且这两个单词互不相同时才能查找
            return words.length;
        }
        if (indexArr1.size() > indexArr2.size()){//优化：总是让形参indexArr1指向较短的索引集合，形参indexArr2指向较长的索引集合，这样，我们永远对较短的数组遍历，在较长的数组中二分查找最接近遍历到的元素的区间
            ArrayList<Integer> temp = indexArr1;
            indexArr1 = indexArr2;
            indexArr2 = temp;
        }

        int minDist = Integer.MAX_VALUE;
        int[] searchRes = new int[2];
        for (int index1 : indexArr1){
            searchRes = binarySearch(indexArr2, index1, 0, indexArr2.size() - 1);
            int minCandidate1 = Math.abs(searchRes[0] - index1);
            int minCandidate2 = Math.abs(searchRes[1] - index1);
            minDist = Math.min(Math.min(minCandidate1, minCandidate2), minDist);
        }
        return minDist;
    }
    //这个二分查找找的是indexArr中与target相差最小的数值（target所在的最小区间），其中indexArr是已经排好序了
    public int[] binarySearch(ArrayList<Integer> indexArr, int target, int left, int right){
        //对于小于ArrayList集合中最小值的target，最接近target的值就是这个最小值
        //对于大于ArrayList集合中最大值的target，最接近target的值就是这个最大值
        if (target < indexArr.get(0) || target > indexArr.get(indexArr.size() - 1)){
            return target < indexArr.get(0) ? new int[]{indexArr.get(0), indexArr.get(0)} 
            : new int[]{indexArr.get(indexArr.size() - 1), indexArr.get(indexArr.size() - 1)};
        }
        if (left > right){//基线条件
            return new int[]{indexArr.get(left), indexArr.get(right)};
        }

        int mid = (left + right) / 2;
        if (indexArr.get(mid) > target){//大了，向左半部分查找
            return binarySearch(indexArr, target, left, mid - 1);
        } else if (indexArr.get(mid) < target){//小了，向右半部分查找
            return binarySearch(indexArr, target, mid + 1, right);
        } else {//找到了
            return new int[]{indexArr.get(mid), indexArr.get(mid)};
        }
    }
}
```

## 复杂度分析
- 时间复杂度：$O(NlogN)$，其中$N$为字符串数组的长度，最坏的情况是`words`中一半元素是一个单词，另一半元素是另一个单词，那么我们需要遍历`words`的一半长度的索引集合，然后对另一半长度的索引集合进行二分查找
- 空间复杂度：$O(N)$，最坏的情况是`words`中每个单词都不一样


# 民间解法1

## 基本思路(哈希表+双指针)

与我的思路基本一致，只不过在两个**排好序**的`ArrayList`集合中找到差值最小的两个元素时，可以使用双指针法：一个指针i指向indexArr1，另一个指针j指向indexArr2，
- 如果i指向的元素<j指向的元素，则i++
- 如果i指向的元素>j指向的元素，则j++

这样做每一次找到的都是最小差值的候补