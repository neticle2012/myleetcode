# 05.08. 绘制直线

[力扣题目链接](https://leetcode-cn.com/problems/draw-line-lcci/)


# 初见思路

## 基本思路
以下分析以`length=9`，`w=96`为例子，在这种情况下，屏幕数组`screen`一共有9个元素，可以看作是`3`行`3`列的二维数组

对于直线的区间$[x1,x2]$，横跨该行索引$[x1 / 32, x2 / 32]$（例如行数`y=1`的直线区间$[3,93]$，横跨该行索引$[3 / 32, 93 / 32]=[0, 2]$），加上偏移量`y * (w / 32)`后即为横跨整个数组的索引。每个索引`i`对应的元素`screen[i]`不是所有二进制位都设置为`1`，因此需要计算出每个索引对应元素`screen[i]`的开始位置`start`和结束位置`end`，然后将$[start, end]$区间内索引元素`screen[i]`对应的二进制位置为`1`，具体操作方法为将`1`算数左移后跟`screen[i]`进行按位或运算

## 边界问题
`y`必须满足$y \in [0, \dfrac{length}{\dfrac{w}{32}}]$，`x1,x2`必须满足$0 \le x1 \le x2 < w$，不满足时直接返回`null`

## Java代码
```java
class Solution {
    public int[] drawLine(int length, int w, int x1, int x2, int y) {
        if (!(0 <= y && y < length / (w / 32)) || x1 < 0 || x2 + y * w >= 32 * length){
            return null;
        }
        int[] screen = new int[length];
        int indexBias = y * (w / 32);
        for (int i = x1 / 32; i <= x2 / 32; i++){
            int start = Math.max(x1, 32 * i);
            int end = Math.min(x2, 32 * (i + 1) - 1);
            for (int j = start % 32; j <= end % 32; j++){
                screen[indexBias + i] |= (1 << 31 - j);
            }
        }
        return screen;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(x2-x1)$，我们需要遍历行数`y`的$[x1, x2]$二进制位并将其置为`1`
- 空间复杂度：$O(1)$，不计算返回结果需要的空间

# 民间解法

## 基本思路
对于直线的区间$[x1,x2]$，将横跨该行索引$[x1 / 32, x2 / 32]$加上偏移量`y * (w / 32)`得到横跨整个数组的索引区间$i \in [x1 / 32 + y * (w / 32), x2 / 32 + y * (w / 32)]$后，先将这个区间内的所有元素`screen[i]`都设置为`-1`（因为将`screen[i]`的所有二进制位设置成`1`后，其对应的十进制数为`-1`），然后由于将索引区间最前面和最后面的二进制位也全置为`1`了，需要将多余的`1`给设置回`0`

- 对于最前面的元素（已经将所有二进制位设置成`1`），只需要先将二进制位全是`1`的`int`型数（表示为<strong>二进制补码</strong>是`11...1(32个1)`，表示成十进制是`-1`）无符号右移`x1%32`位，然后将结果跟最前面的元素按位与即可。
	- 也可以直接将最前面的元素无符号右移`x1%32`位
- 对于最后面的元素（已经将所有二进制位设置成`1`），先将二进制位最高位是`1`，其余都是`0`的`int`型数（表示为<strong>二进制补码</strong>是`10...0(31个0)`，表示成十进制是`-2147483648`，即`Integer.MIN_VALUE`）算数右移`x2%32`位，然后将结果跟最后面的元素按位与即可

为什么不能对于最后面的元素直接算数左移`31-x2%32`位呢？因为如果最前面和最后面的元素是同一个，例如行数`y=1`的直线区间$[3,23]$，横跨该行索引$[3 / 32, 29 / 32]=[0, 0]$，加上偏移量后索引区间为$[0, 0]$，将`screen[0]`的二进制位全部置为`1`后，先使用无符号右移将$[0bit, 2bit]$的二进制位置回`0`没有问题，但是要将$[30bit, 31bit]$的二进制位置回`0`时，如果使用算术左移，则已经置回`0`的二进制位$[0bit, 2bit]$会因为左移而被改变，因此必须在不改变前面已经置回`0`的二进制位的情况下，将后面的二进制位置回`0`

## 注意！！！
以上将某个数表示的二进制数进行位运算指的是<strong>将其二进制数的补码进行位运算</strong>

<img src="../Pictures/05.08. 绘制直线.png" width="90%"/>

## 边界问题
`y`必须满足$y \in [0, \dfrac{length}{\dfrac{w}{32}}]$，`x1,x2`必须满足$0 \le x1 \le x2 < w$，不满足时直接返回`null`

## Java代码
```java
class Solution {
    public int[] drawLine(int length, int w, int x1, int x2, int y) {
        if (!(0 <= y && y < length / (w / 32)) || x1 < 0 || x2 + y * w >= 32 * length){
            return null;
        }
        int[] screen = new int[length];
        int indexBias = y * (w / 32);
        int start = x1 / 32 + indexBias;
        int end = x2 / 32 + indexBias;//得到画横线涉及到的原数组的索引区间
        for (int i = start; i <= end; i++){//将索引区间内的元素全部二进制位置为1
            screen[i] = -1;
        }
        //然后，将索引区间的首尾进行修正
        screen[start] &= (-1 >>> x1 % 32);//也可以用screen[start] >>>= (x1 % 32)
        screen[end] &= (Integer.MIN_VALUE >> x2 % 32);//绝对不能写成screen[end] <<= (31 - x2 % 32)！！！
        return screen;
    }
}
```
## 复杂度分析
- 时间复杂度：$O(x2 / 32 - x1 / 32 + 1 + 2) = O(x2 / 32 - x1 / 32)$，我们需要遍历行数`y`的索引区间$[x1 / 32, x2 / 32]$，将区间内的元素全部二进制位置为`-1`，然后去修正首尾索引的元素
- 空间复杂度：$O(1)$，不计算返回结果需要的空间