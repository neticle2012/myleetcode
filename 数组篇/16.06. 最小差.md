# 16.06. 最小差

[力扣题目链接](https://leetcode-cn.com/problems/smallest-difference-lcci/)


# 初见思路

## 基本思路(排序+双指针)
首先对两个数组进行排序，然后一个指针`i`指向数组`a`的第一个元素，另一个指针`j`指向数组`b`的第一个元素，用一个变量`min`来保存最小差值，初始化为`Long.MAX_VALUE`
- 如果`a[i]<b[j]`，则比较当前`min`值和$|a[i] - b[j]|$，将最小值更新为`min`，然后`i++`，因为如果`j++`，差值只会越来越大
- 如果`a[i]>=b[j]`，则比较当前`min`值和$|a[i] - b[j]|$，将最小值更新为`min`，然后`j++`，因为如果`i++`，差值只会越来越大
- 最后如果其中一个数组遍历完了就结束遍历，因为另一个数组中没遍历的数字其实都大于已遍历完的数组中最大的数（即最后一个元素），所以没有必要再和另一个数组最大值做差值了，这样差值只会越来越大，没有意义

<img src="../Pictures/16.06. 最小差.png" width="80%"/>

这样，可以将从两个长度不相等的数组中找出最小差值的时间复杂度从$O(AB)$将为$O(A+B)$，其中$A$、$B$分别是两个数组的长度

## 注意溢出！！！
题目提到$-2147483648(-2^{31}) \le a[i], b[i] \le 2147483647(2^{31}-1)$，而且要求返回的差值是`int`型，那么如果数组`a={1}`，数组`b={-2147483648}`，那么最小差值本来应该为`1-(-2147483648)=2147483649`，但是由于`int`型占用存储空间`4`个字节，可表示范围只有（$-2147483648(-2^{31})\sim2147483647(2^{31}-1)$），那么最终结果只能溢出为`-2147483647`。但是，如果在计算$|a[i] - b[j]|$时发生了溢出，那么与当前`min`值比较的结果可能会发生变化，因此需要使用`long`型（占用存储空间`8`个字节，可表示范围是$-2^{63}\sim2^{63}-1$）来接收$|a[i] - b[j]|$，而且变量`min`的初始化值也必须是`long`型的最大值

## 边界问题
`a`数组和`b`数组有一个为`null`，`a`数组和`b`数组有一个长度为`0`时，直接返回`-1`。

## Java代码
```java
class Solution {
    public int smallestDifference(int[] a, int[] b) {
        if (a == null || b == null || a.length == 0 || b.length == 0){
            return -1;
        }
        Arrays.sort(a);
        Arrays.sort(b);
        int i = 0, j = 0;
        long min = Long.MAX_VALUE;
        while (i < a.length && j < b.length){
            //如果a[i] = 2147483647(2^31-1), b[i] = -2147483648(-2^31)，如还用int型接收则必然会发生越界现象
            //因此必须先强制转型为精度更大的long型
            min = Math.min(min, Math.abs((long) a[i] - (long) b[j]));
            if (a[i] < b[j]){
                i++;
            } else {
                j++;
            }
        }
        return (int) min;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(NlogN)$，其中$N$为较长数组的长度，$M$为较长数组的长度。排序两个数组的分别需要$O(NlogN)$和$O(MlogM)$的时间，遍历两个有序数组找出差值需要$O(M+N)$的时间
- 空间复杂度：$O(logN)$，快速排序的递归调用栈需要$O(logN)$的空间