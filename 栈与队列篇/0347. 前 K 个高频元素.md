# 347. 前 K 个高频元素

[力扣题目链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)


# 初见思路

## 基本思路
首先将`nums`从小到大进行排序，然后遍历`nums`，将每个元素和出现的次数添加到`ArrayList`集合中（`ArrayList`集合保存的元素是`Integer`数组，`Integer`数组中保存了每个元素和出现的次数），然后对`ArrayList`集合根据按照出现次数从大到小排序，最后遍历排序后的`ArrayList`集合，取出前`k`个元素然后获取保存的`nums[i]`的出现次数即可

## 边界问题
如果`nums`为`null`或者长度为`0`，则直接返回`null`

## Java代码
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        if (nums == null || nums.length == 0){
            return null;
        }
        ArrayList<Integer[]> list = new ArrayList<>();
        Arrays.sort(nums);
        int cnt = 0;
        for (int i = 0; i < nums.length; i++){
            cnt++;
            if (i == nums.length - 1 || nums[i] != nums[i + 1]){
                list.add(new Integer[]{cnt, nums[i]});
                cnt = 0;
            }
        }
        //对ArrayList集合根据按照出现次数从大到小排序
        Collections.sort(list, new Comparator<Integer[]>(){
            @Override
            public int compare(Integer[] arr1, Integer[] arr2){
                return arr2[0] - arr1[0];
            }
        });
        int[] res = new int[k];
        for (int i = 0; i < k; i++){
            res[i] = list.get(i)[1];
        }
        return res;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(NlogN)$，其中$N$为`nums`数组的长度，对`nums`快速排序需要$O(NlogN)$的时间，遍历`nums`需要$O(N)$的时间，对`ArrayList`集合排序需要$O(DlogD)$的时间，其中$D$为`nums`数组中不同的元素个数，取出排序后`ArrayList`集合的前`k`个元素需要$O(k)$的时间
- 空间复杂度：$O(max(logN, D))$，其中$D$为`nums`数组中不同的元素个数，快速排序需要$O(logN)$的递归栈空间，`ArrayList`集合需要$O(D)$的空间，对`ArrayList`集合进行排序需要$O(logD)$的递归栈空间

# 官方解法

学完堆排序再做一遍