# 739. 每日温度

[力扣题目链接](https://leetcode-cn.com/problems/daily-temperatures/)


# 初见思路

## 基本思路
定义一个长度为`71`的数组`arr`（因为温度取值$[30,100]$），用于保存每个温度出现的索引集合，遍历`temperatures`数组，将每个温度出现的索引添加到`arr`对应位置的`ArrayList`集合中，则<strong>每个`ArrayList`集合中的元素必定是从小到大排好序的</strong>

然后再次遍历`temperatures`数组，对于每个元素`temperatures[i]`，依次遍历`arr`数组中下标值$>$`temperatures[i]-30`的`ArrayList`集合（即满足温度$>$`temperatures[i]`的每个温度出现的索引集合），<strong>对遍历到的集合使用二分查找找到最接近`i`且大于`i`的元素`searchRes`</strong>，所有`searchRes-i`中的最小值即为从`i`出发想观测到更高气温至少需要等待的天数

## 边界问题
如果`temperatures`数组为`null`，则直接返回`null`

## Java代码
```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        if (temperatures == null){
            return null;
        }
        List<Integer>[] arr = new List[71];//存放每个温度出现的索引集合
        for (int i = 0; i < temperatures.length; i++){
            int arrIndex = temperatures[i] - 30;
            if (arr[arrIndex] == null){
                arr[arrIndex] = new ArrayList<>();
            }
            arr[arrIndex].add(i);
        }

        int[] min = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++){
            min[i] = Integer.MAX_VALUE;
            int arrIndex = temperatures[i] - 30;
            for (int j = arrIndex + 1; j < arr.length; j++){
                if (arr[j] == null){
                    continue;
                }
                int searchRes = binarySearchGreater(arr[j], 0, arr[j].size() - 1, i);
                if (searchRes == -1){//没有在arr[j]中找到大于 i 的值
                    continue;
                }
                //下面处理在arr[j]中找到了大于 i 的值的逻辑
                min[i] = Math.min(min[i], searchRes - i);    
            }
            min[i] = min[i] == Integer.MAX_VALUE ? 0 : min[i];
        }
        return min;
    }
    //方法：二分查找到距离target最近且大于target的值
    public int binarySearchGreater(List<Integer> list, int left, int right, int target){
        if (left > right){//基线条件
            return left == list.size() ? -1 : list.get(left);//如果left = list的大小，说明list中没有大于target的值。例如list={1,4,5,9}, target=11
        }
        int mid = (left + right) / 2;
        if (target > list.get(mid)){
            return binarySearchGreater(list, mid + 1, right, target);
        } else {//target < list.get(mid)，绝对不会出现相等的情况
            return binarySearchGreater(list, left, mid - 1, target);
        }
    }
}
```

## 复杂度分析
- 时间复杂度：$O(N|\Sigma|logN)$，其中$N$为`temperatures`数组的长度，$|\Sigma|$为`arr`数组的长度（即温度的取值总数）
- 空间复杂度：$O(|\Sigma|N)$，此为`arr`的空间消耗


# 官方解法

## 基本思路

可以进行进一步优化，

对于温度列表中的每个元素 `temperatures[i]`，需要找到最小的下标 `j`，使得 `i < j` 且 `temperatures[i] < temperatures[j]`。

定义一个长度为`71`的数组`arr`（因为温度取值$[30,100]$），用于保存每个温度<strong>第一次出现的下标</strong>。数组`arr`中的元素初始化为无穷大（即`Integer.MAX_VALUE`），在遍历`temperatures`数组的过程中更新`arr`的值。

<strong>从后向前反向遍历`temperatures`数组</strong>。对于每个元素 `temperatures[i]`，在数组`arr`中找到从 `temperatures[i] + 1` 到 `100` 中每个温度第一次出现的下标，将其中的最小下标记为 `warmerIndex`，则 `warmerIndex` 为下一次温度比当天高的下标。如果 `warmerIndex` 不为无穷大，则` warmerIndex - i` 即为下一次温度比当天高的等待天数，最后将`temperatures[i]`的出现索引`i`更新到`arr`数组的对应位置中，即`arr[temperatures[i]-30] = i`。

解释：因为遍历`temperatures`数组的方向是反向，当遍历到元素 `temperatures[i]` 时，<strong>只有 `temperatures[i]` 后面的元素被访问过</strong>，从这些后面的元素中筛选出满足温度$>$`temperatures[i]`的元素，<strong>它们在`arr`数组中对应位置的元素（即最小出现索引）必定$>$`i`</strong>，因此只需要从其中找到最小值，即为下一次温度比当天高的下标。
由于每反向遍历到`temperatures`数组中的一个元素，最后会将这个元素的出现索引更新到`arr`数组的对应位置中，保证了`temperatures[i]` 后面的元素在`arr`数组中对应位置的元素是在索引区间$[i, temperatures.length]$内必定是最小的出现索引

## 边界问题
如果`temperatures`数组为`null`，则直接返回`null`

## Java代码
```java

```

## 复杂度分析
- 时间复杂度：$O(N|\Sigma|)$，其中$N$为`temperatures`数组的长度，$|\Sigma|$为`arr`数组的长度（即温度的取值总数）。反向遍历`temperatures`数组一遍，对于数组中的每个值，都要遍历`arr`一遍。
- 空间复杂度：$O(|\Sigma|)$，此为`arr`的空间消耗