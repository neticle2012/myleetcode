# 17.21. 直方图的水量

[力扣题目链接](https://leetcode-cn.com/problems/volume-of-histogram-lcci/)


# 初见思路

## 基本思路
维护一个存储`Node`对象（每个`Node`对象有`heights`数组的元素`val`、<strong>该元素前面的最大值`prevMax`和当前累积出栈的元素个数`popCnt`</strong>三个属性）的单调栈`stack`，<strong>从栈底到栈顶的下标对应的的温度依次递增</strong>。如果一个`Node`对象在单调栈里，则表示尚未找到该`height`数组元素可以勾勒出的最大矩形。整个算法的核心是，<strong>每次有新元素进栈时，会将`val`更大的元素全部出栈，并计算出出栈元素的面积去更新面积最大值</strong>

具体来说，遍历`heights`数组，对于每个元素`heights[curTime]`，

- 如果当前`stack`为空，或者`heights[curTime]` $\ge$ 当前栈顶`Node`对象的`val`，则说明<strong>使用`heights[curTime]`勾勒出的最大矩形的左边界为`curTime`</strong>（因为递增栈的栈顶元素的`val`是最大的，`heights[curTime]`比最大的`val`还要大，而栈顶及以下的元素也是`heights[curTime]`前面的元素，说明这些元素绝对不可能是`heights[curTime]`勾勒出的最大矩形的一部分），则新创建一个`Node`对象，其属性`val=heights[curTime]`，`prevTime=curTime`，`push`进`stack`中
- 如果`heights[curTime]`$<$ 当前栈顶`Node`对象的`val`，则说明对于该栈顶元素`popNode`而言，其可以勾勒出的最大矩形的右边界（<strong>注意取不到右边界</strong>）止于`curTime`，则以`popNode`为高度的最大矩形位于区间$[popNode.prevTime, curTime)$之内
	1. 先计算栈顶元素可以勾勒出的最大矩形面积`Area = popNode.val * (curTime - popNode.prevTime)`去更新面积最大值
	2. <strong>还必须要把将要入栈的`Node`对象（即以`heights[curTime]`为`val`属性创建的`Node`对象）的`prevTime`属性更新为`popNode.prevTime`。</strong>这是因为出栈的元素也是`heights[curTime]`勾勒出的最大矩形的一部分
	3. 然后将栈顶元素`pop`出栈，再比较`heights[curTime]`和新的栈顶的元素的`val`，直到当前`stack`为空或者`heights[curTime]` $\ge$ 当前栈顶`Node`对象的`val`（也就是变成了上一种情况了），按照上一种情况的逻辑将`heights[curTime]`入栈，只不过`prevTime`属性要用更新过后的

遍历到数组最后，对于栈中还剩余的所有元素，使用它们能勾勒出的最大矩形的右边界必定为`curTime=heights.length`，则将它们依次出栈，分别计算可以勾勒出的最大矩形面积`Area = popNode.val * (curTime - popNode.prevTime)`去更新面积最大值

## 边界问题
如果数组为`null`，直接返回`-1`

## Java代码
```java
class Solution {
    public int trap(int[] height) {
        if (height == null){
            return -1;
        }
        int res = 0;
        Deque<Node> stack = new LinkedList<>();//单调栈，从栈底到栈顶依次递减
        for (int item : height){
            int popCnt = 1;
            while (!stack.isEmpty() && item > stack.peek().val){
                Node popNode = stack.pop();
                res += (Math.min(popNode.prevMax, item) - popNode.val) * popNode.popCnt;
                popCnt += popNode.popCnt;
            }
            int prevMax = stack.isEmpty() ? item : stack.peek().prevMax;
            stack.push(new Node(item, prevMax, popCnt));
        }
        return res;
    }
}

class Node {
    int val; 
    int prevMax;//该元素前面的最大值（即单调栈栈底的值）
    int popCnt;//popCnt = 当前累积出栈的元素个数 + 1（这个元素）
    //只有当this.val > 栈顶元素.val致使栈顶元素出栈时，才将栈顶元素的popCnt累加到this.popCnt上

    public Node(int val, int prevMax, int popCnt){
        this.val = val;
        this.prevMax = prevMax;
        this.popCnt = popCnt;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(1)$
- 空间复杂度：$O(Nk)$，其中$N$为每个栈的大小，$k$为我们需要实现的栈的个数，本题中为$k=3$


# 民间解法

## 基本思路


## 边界问题


## Java代码
```java

```

## 复杂度分析
- 时间复杂度：$O(1)$
- 空间复杂度：$O(Nk)$，其中$N$为每个栈的大小，$k$为我们需要实现的栈的个数，本题中为$k=3$