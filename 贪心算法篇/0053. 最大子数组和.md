# 53. 最大子数组和

[力扣题目链接](https://leetcode-cn.com/problems/maximum-subarray/)


# 初见思路(超出时间限制)

## 基本思路

两层for循环，第一层设置起始位置，第二层循环遍历数组寻找最大值

## 边界问题

如果`nums`为`null`或者长度为`0`，直接返回`-1`

## Java代码
```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0){
            return -1;
        }

        int res = Integer.MIN_VALUE;
        for (int i = 0; i < nums.length; i++){
            int sum = 0;
            for (int j = i; j < nums.length; j++){
                sum += nums[j];
                res = Math.max(res, sum);
            }
        }
        return res;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(N^{2})$，其中$N$为数组`nums`的长度
- 空间复杂度：$O(1)$

# 官方解法1

## 基本思路(贪心算法)

<strong>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</strong>（如果 `-2, 1` 在一起，计算起点的时候，一定是从`1`开始计算，因为<strong>负数只会拉低总和</strong>，这就是贪心贪的地方）

全局最优：选取最大“连续和”

局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

从代码角度上来讲：遍历`nums`，从头开始用`sum`累积，如果`sum`一旦加上`nums[i]`变为负数，那么就应该从`nums[i+1]`开始从`0`累积`sum`了，因为已经变为负数的`sum`，只会拖累总和。

这相当于是暴力解法中的不断调整最大子序和区间的起始位置。

而在每次`sum`加上`nums[i]`后，需要及时记录下的新的`sum`去更新结果`res`，<strong>相当于是用`res`记录最大子序和区间和（变相的算是调整了终止位置）</strong>

<img src="../Pictures/53. 最大子数组和.png" width="80%"/>

## 边界问题

如果`nums`为`null`或者长度为`0`，直接返回`-1`

## Java代码
```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0){
            return -1;
        }

        int res = Integer.MIN_VALUE;
        int sum = 0;
        for (int i = 0; i < nums.length; i++){
            sum += nums[i];
            res = Math.max(res, sum);// 取区间累计的最大值（相当于不断确定最大子序终止位置）
            
            if (sum < 0){
                sum = 0;// 相当于重置最大子序起始位置，贪心算法认为遇到负数一定是拉低总和
            }
        }
        return res;
    }
}
```

## 复杂度分析
- 时间复杂度：$O(N)$，其中$N$为数组`nums`的长度
- 空间复杂度：$O(1)$

# 官方解法2

## 基本思路

学完动态规划再做一遍